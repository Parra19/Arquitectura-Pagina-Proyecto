<!DOCTYPE html>
<html>
<head> 
	<title> Arquitectura de Computadoras </title>

	<!-- En esta etiqueta link lo que hacemos es agregar un favicon a nuestra pagina -->
	<link rel = "shortcut icon" href="../Media/Imagenes/pIcon.jpg" type="image/png" />

	<!-- Esta eqtiqueta carga el link de las fuentes de google API -->
	<link rel="preconnect" href="https://fonts.gstatic.com">

	<!-- Esta etiqueta carga los tipos de fuentes -->
	<link href="https://fonts.googleapis.com/css2?family=Dancing+Script&family=Indie+Flower&family=Source+Code+Pro&family=VT323&family=Zilla+Slab+Highlight&display=swap" rel="stylesheet">
	
	<!-- Esta etiqueta carga el CSS -->
	<link rel="stylesheet" type="text/css" href="../CSS/Style.css">
</head>
<body class="Unidad2">
	<br>
	<!-- Barra de Navegacion de los temas y sus enlaces -->
	<nav class="navContenedor">
		<div class="Themes">
			<a class="Blanco" href="Index.html"> Arquitectura de Computadoras </a>
		</div>
		<div class="Themes">
			<a class="Blanco" href="Unidad1.html"> Unidad 1</a>
			<a class="Blanco" href="Unidad2.html"> Unidad 2</a>
			<a class="Blanco" href="Unidad3.html"> Unidad 3</a>
			<a class="Blanco" href="Unidad4.html"> Unidad 4</a>
		</div>
	</nav>

	<div class="textos">
		<p class="titleCripto"> Estructura y funcionamiento de la CPU.</p>
		<p class="titulo"> 2.1 Organización del procesador </p>
		<p class="cuerpo">
			La función principal de un procesador es ejecutar instrucciones y la organización que tiene viene
			condicionada por las tareas que debe realizar y por cómo debe hacerlo. <br><br>

			Los procesadores están diseñados y operan según una señal de sincronización Esta señal, conocida
			como señal de reloj, es una señal en forma de onda cuadrada periódica con una determinada 
			frecuencia. <br><br>

			La Unidad de Procesamiento (CPU) controla el funcionamiento del computador y lleva a cabo sus funciones
			de procesamiento de datos. Frecuentemente se le llama procesador. <br>

			Un procesador, incluye tanto registros visibles por el usuario como registros de control/estado. 
			Los registros visibles por el usuario pueden ser de uso general o tener una utilidad especial, 
			mientras que los registros de control y estado se usan para controlar el funcionamiento del procesador, 
			un claro ejemplo es el contador de programa. <br><br>

			Lleva a cabo una gran variedad de:

				<li class="sourceLi"> Cálculos</li>
				<li class="sourceLi"> Comparaciones numéricas</li>
				<li class="sourceLi"> Transferencias de datos como respuesta a las peticiones de los programas que están<br> siendo ejecutados en memoria.</li>
		</p>
		<img class="org">

		<p class="subtitulo"> Unidad Aritmético-Lógica (ALU) </p>
		<p class="cuerpo"> 
			Recibe los datos sobre los que efectúa operaciones de cálculo y comparaciones. Toma decisiones lógicas 
			(determina si una afirmación es correcta o falsa mediante reglas del algebra de Boole) y devuelve 
			luego el resultado. Todo ello bajo supervisión de la unidad de control.
		</p>

		<p class="subtitulo"> La Unidad de Control (ALU) </p>
		<p class="cuerpo"> 
			Recibe los datos sobre los que efectúa operaciones de cálculo y comparaciones. Toma decisiones lógicas 
			(determina si una afirmación es correcta o falsa mediante reglas del algebra de Boole) y devuelve 
			luego el resultado. Todo ello bajo supervisión de la unidad de control.<br><br>

			La unidad de control le indica al resto del sistema como llevar a cabo las instrucciones de un programa. 
			Comanda las señales electrónicas entre la memoria y la unidad aritmético-lógica, y entre el CPU y los 
			dispositivos de entrada y salida. Para ejecutar cualquier programa, cada comando del mismo se desglosa en 
			instrucciones.<br><br>
			
			Los procesadores utilizan la segmentación de instrucciones para acelerar la ejecución. 
			La segmentación de cauce se puede dividir en ciclo de instrucción en varias etapas separadas que operan 
			secuencialmente, tales como la captación de instrucción, decodificación de instrucción, cálculo de direcciones 
			de operando, ejecución de instrucción y estructura del operando resultado. <br><br>

			A continuación se muestra cómo se organiza un procesador, para esto se tiene que considerar los siguientes requisitos:

			<li class="sourceLi"> Captar instrucciones: el procesador lee una instrucción de memoria (registro, cache o memoria principal).</li>
			<li class="sourceLi"> Interpretar instrucción: la instrucción se codifica para determinar qué acción es necesario.</li>
			<li class="sourceLi"> Captar datos: la ejecución de una instrucción puede exigir leer datos de memoria o de un módulo de E/S.</li>
			<li class="sourceLi"> Procesar datos: la ejecución de una instrucción puede exigir llevar a cabo alguna operación aritmética o lógica con los datos.</li>
			<li class="sourceLi"> Escribir datos: los resultados de una ejecución pueden exigir escribir datos en la memoria o en el módulo de E/S.	</li>
		</p>

		<p class="titulo"> 2.2 Estructura de registro</p>
		<p class="subtitulo"> ¿Qué son los registros del CPU?</p>
		<p class="cuerpo">
			Se emplean para controlar las instrucciones en ejecución, manejar direccionamiento de memoria y propiciar la capacidad aritmética. <br>
			Los registros vienen de tres tipos: datos, direcciones e índice, que tiene lugar en casi todos los aspectos de la 
			operación del CPU. El tamaño de un registro depende del CPU; los más simples tienen registros que aceptan 8 o 16 
			bits de datos y los más complejos tienen registros de 32, 48 o 64 bits.
		</p>

		<p class="subtitulo"> Clasificacion de los registros</p>
		<p class="subtitulo"> 2.2.1 Registros visibles para el usuario.</p>
		<p class="cuerpo">
			<b>Registros de propósito general:</b> Los registros de propósito general son el AX, BX, CX, y DX, de 16 bits. Cada uno de ellos se divide en 
			dos registros de 8 bits, llamados AH y AL, BH y BL, CH y CL, y, DH y DL, H significando High (alto) y L significando Low (bajo), 
			indicando la parte alta o la parte baja del registro correspondiente de 16 bits.<br><br>

			<b>Registro de datos:</b> Un CPU puede funcionar con datos en uno de tres modos: entre dos registros, entre registros y una 
			ubicación de Memoria de acceso al azar (RAM - Random-Access Memory) y entre dos ubicaciones RAM. Como el CPU está conectado 
			directamente a los registros, las operaciones que implican dos registros son las más rápidas; las que se dan entre ubicaciones 
			RAM son las más lentas.  Es decir, junta dos registros, añade un registro a una ubicación RAM, o añade dos ubicaciones RAM. <br><br>

			<b>Registro de direcciones:</b> Para que un CPU pueda almacenar y recuperar datos en RAM, debe tener la dirección de la memoria de 
			la información. Esas operaciones que implican RAM usan registros de dirección de memoria. EL CPU no realiza aritmética en estos 
			registros; en cambio, los usa para ubicar datos que necesita.<br><br>
		</p>

		<p class="subtitulo"> 2.2.2 Registros de control y de estados.</p>
		<p class="cuerpo">
			<b>Registro de índice:</b> Un CPU no puede hacer matemáticas en registros de datos, aunque puede hacerlo indirectamente con un 
			registro de índice. Éste trabaja con los registros de datos, permitiendo a un programa procesar hilos de información eficazmente. <br><br>

			<b>Registros de apuntadores:</b> Los registros SP (apuntador de pila) y BP (apuntador base) están asociados con el registro SS y permiten al sistema 
			acceder a datos en el segmento de la pila. <br><br>

			<b>Registro de punteros de instrucción:</b> El registro IP de 16 bits contiene el desplazamiento de dirección de la siguiente instrucción que se ejecuta. 
			El IP está asociado con el registro CS en el sentido de que el IP indica la instrucción actual dentro del segmento de código que se 
			está ejecutando actualmente en la memoria. <br><br>

			<b>Registros de banderas:</b> Es un registro de 16 bits, de los cuales nueve sirven para indicar el estado actual de la máquina y el resultado del procesamiento.<br>
			La tabla contiene 16 posiciones (de 0 a 15), que son los 16 bits del registro de banderas, numeradas de derecha a izquierda. La posición 0 la 
			encontraremos a la derecha y la posición 15 a la izquierda.

			<li class="sourceLi"> <b>OF (overflow, desbordamiento):</b> Indica desbordamiento del bit de mayor orden después de una operación aritmética de números con signo (1=existe overflow; 0=no existe overflow). Para operaciones sin signo, no se toma en cuenta esta bandera.</li>
			<li class="sourceLi"> <b>DF (dirección):</b> Controla la selección de incremento o decremento de los registros SI y DI en las operaciones con cadenas de caracteres (1=decremento automático; 0=incremento). La bandera DF se controla con las instrucciones STD y CLD.</li>
			<li class="sourceLi"> <b>IF (interrupción):</b> Controla el disparo de las interrupciones (1=habilita las interrupciones; 0=deshabilita las interrupciones). La interrupción no enmascarable es la única que no puede ser bloqueada por esta bandera. El estado de la bandera IF se controla con las instrucciones STI y CLI.</li>
			<li class="sourceLi"> <b>TF (trampa):</b> Permite la operación del procesador en modo de depuración (paso a paso).</li>
			<li class="sourceLi"> <b>SF (signo):</b> Contiene el signo resultante de una operación aritmética (0=positivo; 1=negativo).</li>
			<li class="sourceLi"> <b>ZF (cero):</b> Indica el resultado de una operación aritmética o de comparación (0=resultado diferente de cero; 1=resultado igual a cero).</li>
			<li class="sourceLi"> <b>AF (acarreo auxiliar):</b> Contiene el acarreo del bit 3. Esta bandera se prueba con las instrucciones DAA y DAS para ajustar el valor de AL después de una suma o resta BCD.</li>
			<li class="sourceLi"> <b>PF (paridad):</b> Indica si el número de bits 1, del byte menos significativos de una operación, es par (0=número de bits 1 es impar; 1=número de bits 1 es par).</li>
			<li class="sourceLi"> <b>CF (acarreo):</b> Contiene el acarreo del bit de mayor orden después de una operación aritmética; también almacena el contenido del último bit en una operación de desplazamiento o de rotación.</li>
		</p>
		<p class="cuerpo">
			<b>Registros de segmento:</b> Un registro de segmento tiene 16 bits de longitud y facilita un área de memoria para direccionamiento 
			conocida como segmento actual.

				<li class="sourceLi"><b>Registro CS:</b> el dos almacena la dirección inicial del segmento de código de un programa en el registro CS. Indica la dirección de una instrucción que es buscada para su ejecución.</li>
				<li class="sourceLi"><b>Registro DS:</b> genera una referencia a la localidad de un byte específico en el segmento de datos.</li>
				<li class="sourceLi"><b>Registro SS:</b> permite la colocación en memoria de una pila, para almacenamiento temporal de dirección y datos.</li>
				<li class="sourceLi"><b>Registro ES:</b> se utiliza para algunas operaciones con cadenas de caracteres se utiliza para el manejo de direccionamiento de memoria.</li>
		</p>

		<p class="subtitulo"> 2.2.3 Ejemplos de registros de CPU reales.</p>
		<p class="cuerpo">
			Ejemplos de registros de CPU reales <br><br>

			En algún diseño concreto de procesador es posible encontrar otros registros relativos a estado y control. 
			Puede existir un puntero a un bloque de memoria que contenga información de estado adicional (por ejemplo, bloques de control de procesos). 
			En las máquinas que usan interrupciones vectorizadas puede existir un registro de vector de interrupción. Si se utiliza una pila 
			para llevar a cabo ciertas funciones (por ejemplo, llamada a subrutina), se necesita un puntero de pila del sistema. 
			En un sistema de memoria virtual se usa un puntero a la tabla de páginas. Por último, pueden emplearse registros para el 
			control de operaciones de E/S. <br><br>

			En el diseño de la organización de los registros de control y estado entran en juego varios factores. <br>
			Una cuestión primordial es el soporte del sistema operativo. Algunos tipos de información de control son de utilidad 
			específica para el sistema operativo. Si el diseñador del procesador posee una comprensión funcional del sistema operativo 
			que se va a utilizar, la organización de los registros puede adaptarse hasta cierto punto a ese sistema operativo.<br>

			Otra decisión importante en el diseño es la distribución de información de control entre registros y memoria. Es 
			frecuente dedicar los primeros (más bajos) pocos cientos o miles de palabras de memoria para fines de control. 
			El diseñador debe decidir cuánta información de control debiera estar en registros y cuánta en memoria. 
			Se presenta el compromiso habitual entre coste y velocidad. <br>
		</p>

		<p class="titulo">2.3 El ciclo de instrucción.</p>
		<p class="cuerpo">
			Un ciclo de instrucción incluye los siguientes subciclos:
				<li class="sourceLi"> Captación: llevar la siguiente instrucción de la memoria al procesador.</li>
				<li class="sourceLi"> Ejecución: interpretar el código de operación y llevar a cabo la operación indicada.</li>
				<li class="sourceLi"> Interrupción: si las interrupciones están habilitadas y ha ocurrido una interrupción, guardar el estado del proceso actual y atender la interrupción.</li>
		</p>

		<p class="subtitulo"> 2.3.1 Ciclo Fetch-Decode-Execute</p>
		<p class="cuerpo">
			El encargado de ejecutar un programa en una computadora u otro sistema computacional es el CPU, lo realiza siguiendo el llamado ciclo Fetch-Decode-Execute, 
			con este ciclo se ejecutan todas las tareas que una computadora puede realizar. <br>

			Fases(o sub ciclos): búsqueda  y ejecución (cada fase tiene etapas o actividades)

			Fase Fetch
				<li class="sourceLi">Cargar la siguiente instrucción </li>
				<li class="sourceLi">Incrementar el secuenciador</li>
				<li class="sourceLi">Interpretar la Instrucción</li>

			<p class="cuerpo">Fase Execute </p>
				<li class="sourceLi">Cargar los operandos </li>
				<li class="sourceLi">Ejecutar la operación</li>
				<li class="sourceLi">Guardar el resultado </li>
				<li class="sourceLi">Verificar si hay solicitudes de interrupción </li>
		</p>

		<p class="subtitulo"> 2.3.2 Segmentación de instrucciones</p>
        <p class="cuerpo">
            La segmentación de cauce(pipelining)es una forma particularmente efectiva
            de organizar el hardware de la CPU para realizar más de una operación al
            mismo tiempo.<br><br>
            
			Consiste en descomponer el proceso de ejecución de las instrucciones en fases o etapas
            que permitan una ejecución simultánea.<br><br>
            
			Explota el paralelismo entre las instrucciones de un flujo secuencial.<br><br>
			
			Ejemplo de estrategia
                <li class="sourceLi">Similar a la línea de armado en una planta de manufactura.</li>
                <li class="sourceLi">El producto pasa por varios estados en el proceso de producción.</li>
                <li class="sourceLi">Por lo tanto, varios productos pueden ser manipulados simultáneamente (cada uno en estados distintos).</li>
                <li class="sourceLi">Se puede comenzar el proceso nuevamente(entrada a la línea de producción) antes de que salga el producto final de la misma.</li>
		</p>
		
		<p class="subtitulo"> 2.3.3 Conjunto de instrucciones. Características y funciones.</p>
		<p class="cuerpo">
			El conjunto de instrucciones que maneja una computadora es una pieza fundamental para el funcionamiento
            de ésta debido a que las instrucciones se comunican directamente con el procesador para hacer un manejo
			adecuado de los datos que están procesando y dependiendo del tipo de set de instrucciones que un CPU
            entienda nos dirá el tipo de programas que una computadora puede llegar o no a soportar, esto responde
            muchas veces a las interrogantes de porque no podemos utilizar las mismas aplicaciones de un dispositivo
            a otro y muchas veces es por la diferencia de procesadores y el conjunto de instrucciones que maneja uno
            respecto al otro. Sin embargo aunque haya diferencias, los conjuntos de instrucciones mantienen ciertas
            características que distinguen ciertas funciones que generalmente deben de estar presentes en los distintos
            sets que existen, a continuación se describirán algunas de estas características:<br><br>

			<b>Ortogonales (Simétricas)</b><br>
			La ortogonalidad es una característica de las instrucciones que es considerada algo amplia en términos de lo que 
			requiere una instrucción o un set de instrucciones para ser considerado ortogonal en primera instancia se dice que 
			las instrucciones en un set deben de poder ser fuente y destino de cualquier elemento de la arquitectura del CPU 
			con esto se refiere a que las instrucciones no solo deben de ser independientes en el sentido de que cada una 
			haga una función única y distinta que no repita lo que hace otra, sino que en conjunto el set de instrucciones 
			debe de ser independiente y consistente en el sentido de que cualquier operando pueda ser direccionado con 
			cualquier tipo de direccionamiento y cualquier tipo de direccionamiento pueda direccionar a cualquier tipo de 
			operando en una instrucción, así que por ejemplo no puede existir un registro que sea para un tipo específico de 
			operando. Entre más de esta característica posea un set de instrucciones se dice que es más ortogonal que otro.<br><br>

			<b>CISC</b><br>
			Un juego de instrucciones Cisc se caracteriza por un número reducido de instrucciones además del uso de pipelining 
			que permite al procesador dividir la ejecución de una instrucción en distintas fases incrementando de esa manera 
			la velocidad de ejecución. Otra característica importante es el uso de instrucciones Ortogonales (explicadas 
			anteriormente) lo cual le permite que cualquier tipo de operando pueda direccionarse de distintas formas. 
			A la hora de realizar operaciones de distintos tipos Cisc solo permite que estas operaciones sean realizadas 
			sobre registros, no permite trabajar sobre memoria a menos que sean instrucciones exclusivamente para accesar a 
			memoria o para guardar datos en memoria, por eso mismo Cisc brinda una muy basta cantidad de registros para 
			trabajar sobre estos.<br><br>

			Enfocándonos en la forma de programar con un juego de instrucciones Cisc, esto generalmente requiere de más
			código debido a la simplicidad de sus instrucciones y a la poca cantidad con las que se cuenta para trabajar.<br><br>

			<b>RISC</b><br>
			A diferencia del set de instrucciones Cisc, este set tiene una cantidad de instrucciones considerable pero dichas 
			instrucciones no suelen ejecutarse por medio de segmentación o pipelining, sus instrucciones no son ortogonales 
			eso quiere decir que se debe tener cuidado con los registros que se utilizan debido a que no se pueden direccionar 
			de cualquier forma los datos sobre cualquier registro, se debe especificar en la instrucción.<br><br>

			La computadora realiza operaciones con los datos que tiene almacenados en memoria, produce nuevos datos o información 
			para uso externo. Las arquitecturas y los conjuntos de instrucciones se pueden clasificar considerando los siguientes 
			aspectos:

				<li class="sourceLi"><b>Almacenamiento de operandos en la CPU:</b> dónde se ubican los operandos aparte de la memoria.</li>
                <li class="sourceLi"><b>Número de operandos explícitos por instrucción:</b> uántos operandos se expresan en forma explícita en una instrucción típica. Normalmente son 0, 1, 2 y 3.</li>
                <li class="sourceLi"><b>Posición del operando:</b> ¿Puede cualquier operando estar en memoria?, o deben estar algunos o todos en los registros internos de la CPU. Cómo se especifica la dirección de memoria (modos de direccionamiento disponibles).</li>
                <li class="sourceLi"><b>Operaciones:</b> Qué operaciones están disponibles en el conjunto de instrucciones. Tipo y tamaño de operandos y cómo se especifican.</li>
		</p>

		<p class="subtitulo"> 2.3.4 Modos de direccionamiento</p>
		<p class="cuerpo">
			Contar con diferentes formatos de instrucciones, implica contar con diferentes formas de obtener los operandos de las instrucciones. 
			Por lo general a estas múltiples formas se les conoce como modos de direccionamiento. Los modos de direccionamiento en MIPS son:<br><br>

			<b>Direccionamiento por registro:</b> donde los operandos son registros. Los datos a operar están contenidos en 2 
			registros de 32 bits y el resultado será colocado en otro registro, del mismo tamaño. Ejemplos de instrucciones que 
			usan este modo de direccionamiento: add, sub, slt, etc.
			<img class="dpr"><br><br>
			
			<b>Direccionamiento base o desplazamiento:</b> donde uno de los operandos está en una localidad de memoria cuya dirección es 
			la suma de un registro y una constante que forma parte de la misma instrucción. Ejemplos de instrucciones que usan este 
			modo de direccionamiento: lw, sw, etc.
			<img class="db"><br><br>

			<b>Direccionamiento inmediato:</b> donde uno de los operandos es una constante que está en la misma instrucción. 
			Ejemplos de instrucciones que usan este modo de direccionamiento: addi, slti, etc.
			<img class="di"><br><br>

			<b>Direccionamiento relativo al PC:</b> donde se forma una dirección sumando una constante, que está en la instrucción, 
			con el registro PC (Program Counter). El resultado de la suma corresponde a la dirección destino si un brinco 
			condicional se va a realizar. Ejemplos de instrucciones que usan este modo de direccionamiento: beq y bne.
			<img class="dr"><br><br>

			<b>	Direccionamiento pseudo directo:</b> donde la dirección destino de un salto corresponde a la concatenación de 26 bits 
			que están en la misma instrucción con los bits más significativos del PC. Ejemplos de instrucciones que usan este 
			modo de direccionamiento: j y jal.
			<img class="dps"><br><br>

			Es importante mencionar que estamos estudiando una arquitectura con direcciones de 32 bits, sin embargo, MIPS, 
			como muchas otras arquitecturas, tiene una extensión que maneja direcciones de 64 bits. Esto como una respuesta a 
			la necesidad de manejar programas cada vez más grandes.
		</p>
	</div>

</body>
</html>